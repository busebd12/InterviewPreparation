from collections import deque

class Solution:
    def __init__(self):
        self.connected_component_size=0

        self.number_of_infected_nodes=0
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        result=-1

        n=len(graph)

        visited=[False for _ in range(0, n)]

        initial.sort()

        infected=set(initial)

        max_connected_component_size=0

        for node in initial:
            if visited[node]==False:
                self.dfs(graph, infected, visited, n, node)

                if self.number_of_infected_nodes==1 and max_connected_component_size < self.connected_component_size:
                    max_connected_component_size=self.connected_component_size

                    result=node

                self.connected_component_size=0

                self.number_of_infected_nodes=0

        return initial[0] if result==-1 else result

    def dfs(self, graph: List[List[int]], infected: Set[int], visited: List[int], n: int, node: int) -> None:
        visited[node]=True

        if node in infected:
            self.number_of_infected_nodes+=1

        self.connected_component_size+=1

        for neighbour in range(0, n):
            if graph[node][neighbour]==1 and visited[neighbour]==False:
                self.dfs(graph, infected, visited, n, neighbour)

class Solution:
    def __init__(self):
        self.connected_component_size=0

        self.number_of_infected_nodes=0
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        result=-1

        n=len(graph)

        visited=[False for _ in range(0, n)]

        initial.sort()

        infected=set(initial)

        max_connected_component_size=0

        for node in initial:
            if visited[node]==False:
                self.dfs(graph, infected, visited, n, node)

                if self.number_of_infected_nodes==1 and max_connected_component_size < self.connected_component_size:
                    max_connected_component_size=self.connected_component_size

                    result=node

                self.connected_component_size=0

                self.number_of_infected_nodes=0

        return initial[0] if result==-1 else result

    def dfs(self, graph: List[List[int]], infected: Set[int], visited: List[int], n: int, node: int) -> None:
        stack=list()

        stack.append(node)

        while stack:
            current=stack.pop()

            if visited[current]==True:
                continue

            visited[current]=True

            if current in infected:
                self.number_of_infected_nodes+=1

            self.connected_component_size+=1

            for neighbour in range(0, n):
                if graph[current][neighbour]==1:
                    stack.append(neighbour)

class Solution:
    def __init__(self):
        self.connected_component_size=0

        self.number_of_infected_nodes=0
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        result=-1

        n=len(graph)

        visited=[False for _ in range(0, n)]

        initial.sort()

        infected=set(initial)

        max_connected_component_size=0

        for node in initial:
            if visited[node]==False:
                self.bfs(graph, infected, visited, n, node)

                if self.number_of_infected_nodes==1 and max_connected_component_size < self.connected_component_size:
                    max_connected_component_size=self.connected_component_size

                    result=node

                self.connected_component_size=0

                self.number_of_infected_nodes=0

        return initial[0] if result==-1 else result

    def bfs(self, graph: List[List[int]], infected: Set[int], visited: List[int], n: int, node: int) -> None:
        queue=deque()

        queue.append(node)

        while queue:
            q_size=len(queue)
            
            for iteration in range(0, q_size):
                current=queue.popleft()

                if visited[current]==True:
                    continue

                visited[current]=True

                if current in infected:
                    self.number_of_infected_nodes+=1

                self.connected_component_size+=1

                for neighbour in range(0, n):
                    if graph[current][neighbour]==1:
                        queue.append(neighbour)