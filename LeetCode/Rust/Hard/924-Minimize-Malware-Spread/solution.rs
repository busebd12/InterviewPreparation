use std::collections::{HashSet, VecDeque};

impl Solution
{
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, mut initial: Vec<i32>) -> i32
    {
        let mut result: i32=-1;

        let n: usize=graph.len();

        let mut visited: Vec<bool>=vec![false; n];

        initial.sort();

        let mut infected: HashSet<i32>=initial.clone().into_iter().collect::<HashSet<i32>>();

        let mut max_connected_component_size: i32=0;

        for node in initial.iter()
        {
            if visited[*node as usize]==false
            {
                let mut number_of_infected_nodes: i32=0;

                let mut connected_component_size: i32=0;
                
                Self::dfs(&graph, &infected, &mut visited, n, &mut number_of_infected_nodes, &mut connected_component_size, *node);

                if number_of_infected_nodes==1 && max_connected_component_size < connected_component_size
                {
                    max_connected_component_size=connected_component_size;

                    result=*node;
                }
            }
        }

        if result==-1
        {
            result=initial[0];
        }

        result
    }

    fn dfs(graph: &Vec<Vec<i32>>, infected: &HashSet<i32>, visited: &mut Vec<bool>, n: usize, number_of_infected_nodes: &mut i32, connected_component_size: &mut i32, node: i32)
    {
        visited[node as usize]=true;

        if infected.contains(&node)
        {
            *number_of_infected_nodes+=1;
        }

        *connected_component_size+=1;

        for neighbour in 0..n
        {
            if graph[node as usize][neighbour]==1 && visited[neighbour]==false
            {
                Self::dfs(graph, infected, visited, n, number_of_infected_nodes, connected_component_size, neighbour as i32);
            }
        }
    }
}

impl Solution
{
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, mut initial: Vec<i32>) -> i32
    {
        let mut result: i32=-1;

        let n: usize=graph.len();

        let mut visited: Vec<bool>=vec![false; n];

        initial.sort();

        let mut infected: HashSet<i32>=initial.clone().into_iter().collect::<HashSet<i32>>();

        let mut max_connected_component_size: i32=0;

        for node in initial.iter()
        {
            if visited[*node as usize]==false
            {
                let mut number_of_infected_nodes: i32=0;

                let mut connected_component_size: i32=0;
                
                Self::dfs(&graph, &infected, &mut visited, n, &mut number_of_infected_nodes, &mut connected_component_size, *node);

                if number_of_infected_nodes==1 && max_connected_component_size < connected_component_size
                {
                    max_connected_component_size=connected_component_size;

                    result=*node;
                }
            }
        }

        if result==-1
        {
            result=initial[0];
        }

        result
    }

    fn dfs(graph: &Vec<Vec<i32>>, infected: &HashSet<i32>, visited: &mut Vec<bool>, n: usize, number_of_infected_nodes: &mut i32, connected_component_size: &mut i32, node: i32)
    {
        let mut stack: Vec<i32>=Vec::new();

        stack.push(node);

        while let Some(current)=stack.pop()
        {
            if visited[current as usize]==true
            {
                continue;
            }

            visited[current as usize]=true;

            if infected.contains(&current)
            {
                *number_of_infected_nodes+=1;
            }

            *connected_component_size+=1;

            for neighbour in 0..n
            {
                if graph[current as usize][neighbour]==1
                {
                    stack.push(neighbour as i32);
                }
            }
        }
    }
}

impl Solution
{
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, mut initial: Vec<i32>) -> i32
    {
        let mut result: i32=-1;

        let n: usize=graph.len();

        let mut visited: Vec<bool>=vec![false; n];

        initial.sort();

        let mut infected: HashSet<i32>=initial.clone().into_iter().collect::<HashSet<i32>>();

        let mut max_connected_component_size: i32=0;

        for node in initial.iter()
        {
            if visited[*node as usize]==false
            {
                let mut number_of_infected_nodes: i32=0;

                let mut connected_component_size: i32=0;
                
                Self::bfs(&graph, &infected, &mut visited, n, &mut number_of_infected_nodes, &mut connected_component_size, *node);

                if number_of_infected_nodes==1 && max_connected_component_size < connected_component_size
                {
                    max_connected_component_size=connected_component_size;

                    result=*node;
                }
            }
        }

        if result==-1
        {
            result=initial[0];
        }

        result
    }

    fn bfs(graph: &Vec<Vec<i32>>, infected: &HashSet<i32>, visited: &mut Vec<bool>, n: usize, number_of_infected_nodes: &mut i32, connected_component_size: &mut i32, node: i32)
    {
        let mut queue: VecDeque<i32>=VecDeque::new();

        queue.push_back(node);

        while !queue.is_empty()
        {
            let q_size: usize=queue.len();

            for iteration in 0..q_size
            {
                let current: i32=queue.pop_front().unwrap();

                if visited[current as usize]==true
                {
                    continue;
                }

                visited[current as usize]=true;

                if infected.contains(&current)
                {
                    *number_of_infected_nodes+=1;
                }

                *connected_component_size+=1;

                for neighbour in 0..n
                {
                    if graph[current as usize][neighbour]==1
                    {
                        queue.push_back(neighbour as i32);
                    }
                }
            }
        }
    }
}